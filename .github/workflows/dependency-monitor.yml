# Dependency Monitoring and Updates
name: Dependency Monitor

on:
  schedule:
    # Run weekly on Monday at 2 AM UTC
    - cron: '0 2 * * 1'
  workflow_dispatch:

jobs:
  dependency-audit:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install audit tools
      run: |
        python -m pip install --upgrade pip
        pip install pip-audit safety
    
    - name: Audit MyBinder requirements
      run: |
        echo "## 🔍 Dependency Audit Report" >> $GITHUB_STEP_SUMMARY
        echo "Generated on: $(date -u)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Create temporary environment for testing
        pip install -r binder/requirements.txt
        
        # Run pip-audit
        echo "### Security Vulnerabilities" >> $GITHUB_STEP_SUMMARY
        if pip-audit --format=json --output=/tmp/audit.json; then
          echo "✅ No vulnerabilities found with pip-audit" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Vulnerabilities detected:" >> $GITHUB_STEP_SUMMARY
          python -c "
          import json
          with open('/tmp/audit.json') as f:
              data = json.load(f)
          for vuln in data.get('vulnerabilities', []):
              print(f'- **{vuln[\"package\"]}** {vuln[\"installed_version\"]}: {vuln[\"description\"]}')
          " >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
    
    - name: Check for outdated packages
      run: |
        echo "### Package Updates Available" >> $GITHUB_STEP_SUMMARY
        pip list --outdated --format=json | python -c "
        import json, sys
        data = json.load(sys.stdin)
        if data:
            print('The following packages have updates available:')
            for pkg in data:
                print(f'- **{pkg[\"name\"]}**: {pkg[\"version\"]} → {pkg[\"latest_version\"]}')
        else:
            print('✅ All packages are up to date')
        " >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
    
    - name: Test MyBinder compatibility with latest packages
      run: |
        echo "### MyBinder Compatibility Test" >> $GITHUB_STEP_SUMMARY
        
        # Create updated requirements for testing
        pip list --format=freeze > /tmp/updated_requirements.txt
        
        # Test basic imports with updated packages
        python -c "
        try:
            import numpy, scipy, matplotlib, jupyter, ipywidgets, plotly, sympy
            print('✅ All core packages import successfully with latest versions')
        except ImportError as e:
            print(f'❌ Import error with updated packages: {e}')
            exit(1)
        " >> $GITHUB_STEP_SUMMARY
    
    - name: Create update PR if needed
      if: github.event_name == 'schedule'
      run: |
        # Check if there are significant updates needed
        outdated_count=$(pip list --outdated --format=json | python -c "import json, sys; print(len(json.load(sys.stdin)))")
        
        if [ "$outdated_count" -gt 5 ]; then
          echo "🔄 $outdated_count packages need updates - consider creating update PR"
          # In a real implementation, this could create a PR automatically
        else
          echo "📋 Only $outdated_count packages need updates - no action needed"
        fi

  mybinder-build-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Test MyBinder build simulation
      run: |
        echo "## 🏗️ MyBinder Build Simulation" >> $GITHUB_STEP_SUMMARY
        echo "Testing whether current configuration can build successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Simulate MyBinder build process
        start_time=$(date +%s)
        
        # Install packages as MyBinder would
        python -m pip install --upgrade pip
        pip install -r binder/requirements.txt
        
        end_time=$(date +%s)
        build_time=$((end_time - start_time))
        
        echo "### Build Results" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Time**: ${build_time} seconds" >> $GITHUB_STEP_SUMMARY
        
        if [ "$build_time" -gt 600 ]; then
          echo "- **Status**: ⚠️ Build time may be too long for MyBinder (>10 minutes)" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Status**: ✅ Build time acceptable for MyBinder" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Test memory usage
        python -c "
        import psutil, os
        process = psutil.Process(os.getpid())
        memory_mb = process.memory_info().rss / 1024 / 1024
        print(f'- **Memory Usage**: {memory_mb:.1f} MB')
        
        if memory_mb > 1500:
            print('- **Memory Status**: ⚠️ High memory usage for MyBinder')
        else:
            print('- **Memory Status**: ✅ Memory usage acceptable')
        " >> $GITHUB_STEP_SUMMARY

  notebook-link-validation:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Validate notebook internal links
      run: |
        echo "## 🔗 Notebook Link Validation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check for broken internal references in notebooks
        find notebooks/ -name "*.ipynb" | while read notebook; do
          echo "Checking $notebook..."
          
          # Extract file references from notebook JSON
          if python -c "
          import json, sys, os
          with open('$notebook') as f:
              data = json.load(f)
          
          broken_links = []
          for cell in data.get('cells', []):
              if cell.get('cell_type') == 'markdown':
                  source = ''.join(cell.get('source', []))
                  # Look for local file references
                  import re
                  matches = re.findall(r'\[.*?\]\(([^)]+)\)', source)
                  for match in matches:
                      if match.startswith('http'):
                          continue  # Skip external links
                      if not match.startswith('/') and not match.startswith('#'):
                          # Relative link
                          full_path = os.path.join(os.path.dirname('$notebook'), match)
                          if not os.path.exists(full_path):
                              broken_links.append(match)
          
          if broken_links:
              print(f'❌ Broken links in $notebook:')
              for link in broken_links:
                  print(f'  - {link}')
              sys.exit(1)
          else:
              print(f'✅ $notebook - no broken links')
          "; then
            echo "✅ $notebook" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ $notebook has broken links" >> $GITHUB_STEP_SUMMARY
          fi
        done